# -*- coding: utf-8 -*-
"""Biopython_Basics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mpyixpcu75rwM17OolBFIogP9kBqpw-T

#Step with main instalation of nessesary packages âœ‰
"""

# install packages
!pip install SeqIO
!pip install biopython

"""#Task1.1.  What is reverse complement for the 'ATCGGTAATGATAGATGA' string?"""

import sys
#Task1.1.
from Bio.Seq import Seq
# Create a DNA sequence
#Note: Modify the line below to work with the string you want to find the reverse complement for
sequence = Seq("ATCGA")
# Get the reverse complement
reverse_complement = sequence.reverse_complement()
# Print the reverse complement
print(reverse_complement)

"""# Task1.2 Example of transcription (DNA to RNA). What is the RNA transcript of "TTCCGATC"?"""

#Task1.2
from Bio.Seq import Seq
# Create a DNA sequence
#Note: Modify the line below to work with the string you want to find the transcript of.
dna_sequence = Seq("ATCGGTA")
# Perform transcription
rna_sequence = dna_sequence.transcribe()
# Print the RNA sequence
print(rna_sequence)

"""# Task1.3 Translation (DNA/RNA to protein). What is protein sequence of the DNA "ATGCCTAATTTAGATGATGATGATGAAGCTTACGTAGATAGA" sequence?"""

from Bio.Seq import Seq
# Create a DNA sequence
#Note: Remember what you need to modify in the line below!
dna_sequence = Seq("ATGCCTAAT")
dna_sequence = Seq("ATTTAGGATGAACTATGTGTGACAAATGGTGCCGTTGAGTCCTCTCAACTGGGAACGAGTCACCGTGTATCTGGAGACCATGTGTGTAACGGGTTGCACCTGCTTGGCTGGATACAAAGGTGGGATTTCTTTCTGTCTTTGTCATCTCTTAGCAGATTGTATCACATTTTGGCTTAATGCTTACTCAGTCATAAGACAAGTTTCTTTTAC")

# Perform translation to a part of the protein
protein_sequence = dna_sequence.translate()
# Print the protein sequence
print('This is your protein sequence', protein_sequence)



# Remember to place my_sequnce.fasta from https://github.com/bazyliszek/OsloMet2025 to /content/sample_data/

from Bio import SeqIO

# Specify the FASTA file path
#fasta_file = "/content/drive/MyDrive/BioPythonClass_OsloMet/2025/my_sequence.fasta"
fasta_file = "/content/sample_data/my_sequence.fasta"

# Read the FASTA file and extract the DNA sequence
for record in SeqIO.parse(fasta_file, "fasta"):
    dna_sequence = record.seq  # Extract the sequence as a Seq object

    # Translate DNA to Protein
    protein_sequence = dna_sequence.translate()

    protein_string = str(protein_sequence)
    proteins = protein_string.split("*")
    # Print the protein sequence
    #print(f"This is my protein sequence: {protein_sequence}")
    for protien in proteins:
      print(protien)

#from google.colab import drive
#drive.mount('/content/drive')

"""In case you mount the google drive"""

#from google.colab import drive
#drive.flush_and_unmount()

"""#Task1.4 Find the 3D structure of your favorite genes in alphafold '  https://alphafold.ebi.ac.uk/ '. # How do you think these structures were derived from? What is model confidence for your protein?"""

#Task 1.4.
#
##########! Answer Task1.4  In general regions on the edge of protein structure is more difficult to predict, this is related to data is more shaky.
##########! Structure is derived from machine learning models, for data where cristography is available
###############################################################################################

#Task5 Sequence Alignment. How many times did you get perfect match for "TTAG"
from Bio import Align
# Create a pairwise sequence aligner
aligner = Align.PairwiseAligner()

# Add sequences to align
seq1 = "ACGTTAGATCTTATTGTAGTTAGGATGATCCTATGATG"
seq2 = "TTAG"
alignments = aligner.align(seq1, seq2)

# Print the alignments
for alignment in alignments:
    print(alignment)


###############################################################################################

"""#Task1.5. Sequence Comparison using biopython. What is the match score of sequence "ATCGGTATTCA" with "ATGGTCATTCA"?"""

#Task1.5.
from Bio import pairwise2
from Bio.Seq import Seq

# Create two DNA sequences
seq1 = Seq("ATCGGTATTCA")
seq2 = Seq("ATGGTTTTTCA") #

# Perform pairwise sequence alignment
alignments = pairwise2.align.globalxx(seq1, seq2)

# Print the alignments
for alignment in alignments:
    print(pairwise2.format_alignment(*alignment))



"""Task 1.6 This is an optional task if you have time. Have a look how FASTA format looks like:"""

#Task 1.6 This is an optional task if you have time. Have a look how FASTA format looks like:
# https://www.ncbi.nlm.nih.gov/nuccore/NM_001130011.3?report=fasta
###############################################################################################



"""**PART 2** Databases

#Task2.1.  Access NCBI database from the page https://www.ncbi.nlm.nih.gov/
#What is the length of NC_000023.11?
"""

import sys
#Task2.1.
# Import the Entrez module from Biopython for accessing NCBI databases

from Bio import Entrez
# Function to fetch genomic sequence using the provided accession number
def fetch_genomic_sequence(accession):
    Entrez.email = "XX.XX@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="nuccore", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "nuccore" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched genomic sequence as a string

# Example usage
genomic_accession = "NC_000019.10"  #Replace with the accession number of your genomic sequence of interest
#sequence = fetch_genomic_sequence(genomic_accession)  # Call the function with the accession number to retrieve the sequence
print(sequence)  # Print the retrieved genomic sequence
print(len(sequence))

"""#Task2.2.  Get protein sequence and name of the protein with ID 'NP_000508'.
# What is the length of this protein? What is the name of the protein ID P01308.1 ?
"""

#Task2.2.

# Import the Entrez module from Biopython for accessing NCBI databases
from Bio import Entrez

# Function to fetch protein sequence using the provided accession number
def fetch_protein_sequence(accession):
    Entrez.email = "marcin.bazyliszek@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="protein", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "protein" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched protein sequence as a string

# Example usage
protein_accession = "NP_000508"  # Replace with the accession number of your protein of interest
sequence = fetch_protein_sequence(protein_accession)  # Call the function with the accession number to retrieve the sequence
print(sequence)  # Print the retrieved protein sequence
print(len(sequence))

#Task2.3  Work a bit with mrna sequence. To which species and gene the mRNA ID "NM_000518" belongs to?
# How many times this sequence has changed?

# Import the Entrez module from Biopython for accessing NCBI databases
from Bio import Entrez

# Function to fetch mRNA sequence using the provided accession number
def fetch_mrna_sequence(accession):
    Entrez.email = "marcin.bazyliszek@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="nucleotide", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "nucleotide" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched mRNA sequence as a string

# Example usage
mrna_accession = "NM_000518"  # You can also replace with the accession number of your mRNA of interest
sequence = fetch_mrna_sequence(mrna_accession)  # Call the function with the accession number to retrieve the sequence
print(sequence)  # Print the retrieved mRNA sequence

# Task2.4 Can you inspect how version 1 vs 5 of NM_000518 has changed?
mrna_accession_1 = "NM_000518.1"
sequence_1 = fetch_mrna_sequence(mrna_accession)
print(sequence_1)
print('The length of v1 is', len(sequence_1))

mrna_accession_5 = "NM_000518.5"
sequence_5 = fetch_mrna_sequence(mrna_accession_5)
print(sequence_5)
print('The length of v5 is', len(sequence_5))

from Bio import pairwise2
from Bio.Seq import Seq
alignments = pairwise2.align.globalxx(sequence_1, sequence_5)

for alignment in alignments:
    print(pairwise2.format_alignment(*alignment))

# Task2.5 Get the genomic Sequence from accession number 'NM_000518', which subunit of a protein is this?
# Import the Entrez module from Biopython for accessing NCBI databases 'NM_000518'
from Bio import Entrez
# Function to fetch genomic sequence using the provided accession number
def fetch_genomic_sequence(accession):
    Entrez.email = "marcin.bazyliszek@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="nuccore", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "nuccore" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched genomic sequence as a string

# Example usage
genomic_accession = "NM_000518"  # Replace with the accession number of your genomic sequence of interest
sequence = fetch_genomic_sequence(genomic_accession)  # Call the function with the accession number to retrieve the sequence
print('This sequence is as following:', sequence)  # Print the retrieved genomic sequence
print(len(sequence))

# Task2.6 PDB Structure Retrival

# Import the PDBList module from Biopython for accessing the Protein Data Bank (PDB)
from Bio.PDB import PDBList

# Function to fetch PDB structure using the provided PDB ID
def fetch_pdb_structure(pdb_id):
    pdbl = PDBList()
    # Create a PDBList object to interact with the PDB database

    pdbl.retrieve_pdb_file(pdb_id, file_format="pdb", pdir="./")
    # Use the retrieve_pdb_file method to fetch the PDB structure with the given PDB ID
    # 'file_format="pdb"' specifies that the data should be returned in PDB format (structure data).
    # 'pdir="./"' indicates that the downloaded PDB file will be saved in the current directory.

    pdb_filename = f"pdb{pdb_id.lower()}.ent"
    # The downloaded PDB file will have a filename in the format "pdbXXXX.ent", where XXXX is the PDB ID in lowercase.

    return pdb_filename  # Return the filename of the downloaded PDB structure


# Example usage
pdb_id = "1CRN"  # Replace with the PDB ID of the structure you want to retrieve (1CRN)
pdb_filename = fetch_pdb_structure(pdb_id)  # Call the function with the PDB ID to retrieve the structure
print(f"PDB structure {pdb_id} downloaded as {pdb_filename}")  # Print the filename of the downloaded PDB structure

#Inspect the file that was created pdb1crn.ent

# Task2.7 Querying Database with TEX101 gene. What are other synonyms of this gene?
# Import necessary modules from Biopython
from Bio import Entrez, Medline, SeqIO

# Set your email address for NCBI Entrez access
Entrez.email = "marcin.bazyliszek@gmail.com" #use your email account

# Use Entrez to retrieve information about available databases
handle = Entrez.einfo()
rec = Entrez.read(handle)
print(rec)

# Search for nucleotide sequences with gene name "TEX101" from "Homo sapiens" # was CRT and  Plasmodium falciparum
handle = Entrez.esearch(db="nucleotide", term='TEX101[Gene Name] AND "Homo sapiens"[Organism]')
rec_list = Entrez.read(handle)

# If there are more results than the default limit, fetch all results
if int(rec_list['RetMax']) < int(rec_list['Count']):
    handle = Entrez.esearch(db="nucleotide", term='TEX101[Gene Name] AND "Homo sapiens"[Organism]',
                            retmax=rec_list['Count'])
    rec_list = Entrez.read(handle)

# Retrieve the list of matching sequence IDs
id_list = rec_list['IdList']

# Fetch the records corresponding to the retrieved IDs in GenBank format
hdl = Entrez.efetch(db='nucleotide', id=id_list, rettype='gb', retmax=rec_list['Count'])
recs = list(SeqIO.parse(hdl, 'gb'))

# Search for a specific sequence with name "NM_001130011"
for rec in recs:
    if rec.name == 'NM_001130011':  #was KM288867
        break
print(rec.name)
print(rec.description)

# Analyze sequence features
for feature in rec.features:
    if feature.type == 'gene':
        print(feature.qualifiers['gene'])
    elif feature.type == 'exon':
        loc = feature.location
        print('Exon', loc.start, loc.end, loc.strand)
    else:
        print('not processed:\n%s' % feature)

# Print annotations of the retrieved sequence
for name, value in rec.annotations.items():
    print('%s=%s' % (name, value))

# Print the length of the sequence
print(len(rec.seq))

# Retrieve and display the references associated with the sequence
refs = rec.annotations['references']
print(refs)
for ref in refs:
    if ref.pubmed_id != '':
        print(ref.pubmed_id)
        handle = Entrez.efetch(db="pubmed", id=[ref.pubmed_id],
                                rettype="medline", retmode="text")
        records = Medline.parse(handle)
        for med_rec in records:
            for k, v in med_rec.items():
                print('%s: %s' % (k, v))

# Task2.8 Filtering retrieved data
# Import the SeqIO module from Biopython for parsing sequence data from files
from Bio import SeqIO

# Function to filter sequences based on their length
def filter_sequences_by_length(sequences, min_length):
    filtered_sequences = []  # Create an empty list to store the filtered sequences
    for sequence in sequences:
        if len(sequence) >= min_length:
            # Check if the length of the sequence is greater than or equal to the minimum length
            # If the condition is met, add the sequence to the filtered_sequences list
            filtered_sequences.append(sequence)
    return filtered_sequences  # Return the list of filtered sequences

# Example usage
fasta_file = "sequence.fasta"  # Replace with the filename of your FASTA file containing sequences
fasta_file = "my_sequence.fasta"  # Replace with the filename of your FASTA file containing sequences
fasta_file = "/content/sample_data/my_sequence.fasta"

# https://www.ncbi.nlm.nih.gov/nuccore/NM_001130011.3?report=fasta
min_length = 100  # Set the minimum length for filtering sequences
sequences = SeqIO.parse(fasta_file, "fasta")  # Parse the FASTA file to get a sequence iterator
filtered_sequences = filter_sequences_by_length(sequences, min_length)  # Call the function to filter sequences
for sequence in filtered_sequences:
    print('My fasta file has following sequence', sequence)  # Print the filtered sequences

# Task2.9 Reading and writing. What is the ID of the fastqc? What is the length of it?
from Bio import SeqIO
# Read sequences from a FASTA file
#sequences = SeqIO.parse("sequence.fasta", "fasta")
sequences = SeqIO.parse("/content/sample_data/my_sequence.fasta", "fasta")

# Iterate over the sequences and print their IDs and lengths
for sequence in sequences:
    print("ID:", sequence.id)
    print("Length:", len(sequence))

"""#PART 3 - Single cell analysis - if you made to this part that means you deserve some additional credits to perform differential analysis"""

!pip install pydeseq2
#!pip install --upgrade numpy
#https://pydeseq2.readthedocs.io/en/stable/
#!pip install --upgrade scikit-learn==1.3.0 scanpy==1.9.3

"""#Task3.1. what is the size of the raw imported count object? What is ENSG00000271254? remember to have correct file
#The file you need you can find it here # https://github.com/bazyliszek/OsloMet2025

import sys
from pydeseq2.dds import DeseqDataSet
import pandas as pd
from pydeseq2.ds import DeseqStats

from pydeseq2.dds import DeseqDataSet
import pandas as pd
from pydeseq2.ds import DeseqStats


counts = pd.read_csv('/content/sample_data/2025_count_table_for_deseq_example.csv')
print(counts)
"""

import sys
from pydeseq2.dds import DeseqDataSet
import pandas as pd
from pydeseq2.ds import DeseqStats

counts = pd.read_csv('/content/sample_data/2025_count_table_for_deseq_example.csv')
print(counts)

counts = counts.set_index('Geneid')
print(counts)

counts = counts[counts.sum(axis=1) > 0]
print(counts)

counts = counts.T
print(counts)

metadata = pd.DataFrame(zip(counts.index, ['C', 'C', 'C', 'C', 'RS', 'RS', 'RS', 'RS']), columns=['Sample', 'Condition'])
metadata = metadata.set_index('Sample')
print(metadata)

dds = DeseqDataSet(counts=counts, metadata=metadata, design_factors="Condition")
dds.deseq2()
print(dds)

stat_res = DeseqStats(dds, contrast=['Condition', 'RS', 'C'])
#make summary statistics
stat_res.summary()

res = stat_res.results_df
print(res)

!pip install sanbomics

from sanbomics.tools import id_map
mapper = id_map(species='human')
res['Symbol'] = res.index.map(mapper.mapper)
res = res[res.baseMean >= 10]

print(res)

sigs = res[(res.padj < 0.05) & (abs(res.log2FoldChange) > 0.5)]
print(sigs)

#!pip install --user scanpy
#!pip install --upgrade numpy scikit-learn scanpy
!pip install --upgrade scikit-learn==1.3.0 scanpy==1.9.3

#import scanpy as sc
#sc.tl.pca(dds)
#sc.pl.pca(dds, color='Condition', size=200)

import scanpy as sc
sc.tl.pca(dds, svd_solver='arpack')
sc.pl.pca(dds, color='Condition', size=200)

import numpy as np
import seaborn as sns
dds.layers['normed_counts']
dds.layers['log1p'] = np.log1p(dds.layers['normed_counts'])
dds.layers['log1p']

print(sigs)
dds_sigs = dds[:, sigs.index]
print(dds_sigs)

grapher = pd.DataFrame(dds_sigs.layers['log1p'].T, index=dds_sigs.var_names, columns=dds_sigs.obs_names)
sns.clustermap(grapher, z_score=0, cmap = 'RdYlBu_r')

import pandas as pd
anno = pd.read_csv(filename_sample_annotation)
adata.obs['cell_groups'] = anno['cell_groups']  # categorical annotation of type pandas.Categorical
adata.obs['time'] = anno['time']                # numerical annotation of type float
# alternatively, you could also set the whole dataframe
# adata.obs = anno

senGPT = ['CDKN2A', 'CDKN1A', 'CDKN2B', 'IL6', 'IL8', 'CXCL1', 'CXCL2', 'CXCL3', 'CXCL5',
 'CXCL6', 'MMP1', 'MMP2', 'MMP3', 'MMP9', 'MMP10', 'MMP12', 'MMP13', 'MMP14', 'SERPINE1',
 'IGFBP7', 'SASP', 'CCND1', 'CCNE1', 'BCL2', 'BAX', 'IL1A', 'IL1B', 'IL10', 'TNF', 'TGFB1', 'CCL2', 'CCL5', 'CCL20', 'ICAM1', 'VCAM1', 'RELA', 'STAT1', 'STAT3',
 'HIF1A', 'PTGS2', 'NOX4', 'EDN1', 'COL1A1', 'COL1A2', 'COL3A1', 'TIMP1', 'TIMP2', 'SOD2', 'NRF2',
 'LMNB1', 'GDF15', 'BMP2', 'BMP4', 'BMP6', 'CTGF', 'FGF2', 'FGF7', 'IGFBP2', 'IGFBP3', 'IGFBP4',
 'IGFBP5', 'IGFBP6', 'LOX', 'LOXL2', 'MMP11', 'MMP15', 'MMP16', 'MMP17', 'MMP19', 'MMP20',
 'MMP24', 'MMP25', 'MMP27', 'MMP28', 'ANXA1', 'TP53', 'CDKN1B', 'ATM', 'ATR', 'CHEK1', 'CHEK2',
 'SIRT1', 'SIRT6', 'TERT', 'LMNA', 'RB1', 'E2F1', 'E2F2', 'E2F3', 'CCND2', 'CCND3', 'FOXO1', 'FOXO3', 'FOXO4', 'HSPB1', 'PML', 'SAHF', 'DDIT3', 'XBP1', 'ATF6']

print(senGPT)

dds_sigs[dds_sigs.Symbol.isin(senGPT)].index
dds_sub = dds[:, sigs[sigs.Symbol.isin(senGPT)].index]
grapher = pd.DataFrame(dds_sub.layers['log1p'].T, index=dds_sub.var_names, columns=dds_sub.obs_names)
grapher.index = grapher.index.map(mapper.mapper)
print(grapher)

ax = sns.clustermap(grapher, z_score=0, cmap = 'RdYlBu_r', figsize=(4,4))

from sanbomics.plots import volcano
print(res)
volcano(res, symbol='Symbol', save="volcano.png")
print(grapher.index)
volcano(res, symbol='Symbol', to_label=grapher.index, save="volcano_with_names.png")