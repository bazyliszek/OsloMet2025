# -*- coding: utf-8 -*-
"""Biopython_Basics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mpyixpcu75rwM17OolBFIogP9kBqpw-T

# Instalation of nessesary packages
"""

!pip install SeqIO
!pip install biopython

"""#Task1.1.  What is reverse complement for the 'ATCGGTAATGATAGATGA' string?"""

import sys
#Task1.1. (ok)
from Bio.Seq import Seq
# Create a DNA sequence
#Note: Modify the line below to work with the string you want to find the reverse complement for
sequence = Seq("ATCGA")
# Get the reverse complement
reverse_complement = sequence.reverse_complement()
# Print the reverse complement
print(reverse_complement)

"""# Task1.2 Example of transcription (DNA to RNA). What is the RNA transcript of "TTCCGATC"?"""

#Task1.2
from Bio.Seq import Seq
# Create a DNA sequence
#Note: Modify the line below to work with the string you want to find the transcript of.
dna_sequence = Seq("ATCGGTA")
# Perform transcription
rna_sequence = dna_sequence.transcribe()
# Print the RNA sequence
print(rna_sequence)

"""# Task1.3 Translation (DNA/RNA to protein). What is protein sequence of the DNA "ATGCCTAATTTAGATGATGATGATGAAGCTTACGTAGATAGA" sequence?"""

#Task 1.3
from Bio.Seq import Seq
# Create a DNA sequence (ok)
#Note: Remember what you need to modify in the line below!
dna_sequence = Seq("ATTTAGGATGAACTATGTGTGACAAATGGTGCCGTTGAGTCCTCTCAACTGGGAACGAGTCACCGTGTATCTGGAGACCATGTGTGTAACGGGTTGCACCTGCTTGGCTGGATACAAAGGTGGGATTTCTTTCTGTCTTTGTCATCTCTTAGCAGATTGTATCACATTTTGGCTTAATGCTTACTCAGTCATAAGACAAGTTTCTTTTAC")

# Perform translation to a part of the protein
protein_sequence = dna_sequence.translate()
# Print the protein sequence
print('This is your protein sequence', protein_sequence)

# Remember to place my_sequnce.fasta from https://github.com/bazyliszek/OsloMet2025 to /content/sample_data/

from Bio import SeqIO

# Specify the FASTA file path
#fasta_file = "/content/drive/MyDrive/BioPythonClass_OsloMet/2025/my_sequence.fasta"
fasta_file = "/content/sample_data/my_sequence.fasta"

# Read the FASTA file and extract the DNA sequence
for record in SeqIO.parse(fasta_file, "fasta"):
    dna_sequence = record.seq  # Extract the sequence as a Seq object

    # Translate DNA to Protein
    protein_sequence = dna_sequence.translate()

    protein_string = str(protein_sequence)
    proteins = protein_string.split("*")
    # Print the protein sequence
    #print(f"This is my protein sequence: {protein_sequence}")
    for protien in proteins:
      print(protien)

"""In case you mount the google drive

#Task1.4 Find the 3D structure of your favorite genes in alphafold '  https://alphafold.ebi.ac.uk/ '. # How do you think these structures were derived from? # What is model confidence for your protein?

#In general regions on the edge of protein structure is more difficult to predict, this is related to data is more shaky. Structure is derived from machine learning models, for data where cristography is available

# What is the function of sequence alignment?
"""

from Bio import Align
# Create a pairwise sequence aligner
aligner = Align.PairwiseAligner()

# Add sequences to align
seq1 = "ACGTTAGATCTTATTGTAGTTAGGATGATCCTATGATG"
seq2 = "TTAGGGAAAAAA"
alignments = aligner.align(seq1, seq2)

# Print the alignments
for alignment in alignments:
    print(alignment)


###############################################################################################

"""#Task1.5. Sequence Comparison using biopython. What is the match score of sequence "ATCGGTATTCA" with "ATGGTCATTCA"?"""

#Task1.5.
from Bio import pairwise2
from Bio.Seq import Seq

# Create two DNA sequences
seq1 = Seq("ATCGGTATTCA")
seq2 = Seq("ATGGTTTTTCA") #

# Perform pairwise sequence alignment
alignments = pairwise2.align.globalxx(seq1, seq2)

# Print the alignments
for alignment in alignments:
    print(pairwise2.format_alignment(*alignment))

"""**PART 2** Databases

#Task2.1.  Access NCBI database from the page https://www.ncbi.nlm.nih.gov/
#What is the length of NC_000023.11?
"""

import sys
#Task2.1.
# Import the Entrez module from Biopython for accessing NCBI databases

from Bio import Entrez
# Function to fetch genomic sequence using the provided accession number
def fetch_genomic_sequence(accession):
    Entrez.email = "XX.XX@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="nuccore", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "nuccore" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched genomic sequence as a string

# Example usage
genomic_accession = "NC_000023.11"  #Replace with the accession number of your genomic sequence of interest NC_000019.10
sequence = fetch_genomic_sequence(genomic_accession)  # Call the function with the accession number to retrieve the sequence
print(sequence)  # Print the retrieved genomic sequence
print(len(sequence))

"""#Task2.2.  Get protein sequence and name of the protein with ID 'NP_000508'.
# What is the length of this protein? What is the name of the protein ID P01308.1 ?
"""

#Task2.2.

# Import the Entrez module from Biopython for accessing NCBI databases
from Bio import Entrez

# Function to fetch protein sequence using the provided accession number
def fetch_protein_sequence(accession):
    Entrez.email = "marcin.bazyliszek@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="protein", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "protein" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched protein sequence as a string

# Example usage
protein_accession = "NP_000508"  # Replace with the accession number of your protein of interest
sequence = fetch_protein_sequence(protein_accession)  # Call the function with the accession number to retrieve the sequence
print(sequence)  # Print the retrieved protein sequence
print(len(sequence))

#Task2.3  Work a bit with mrna sequence. To which species and gene the mRNA ID "NM_000518" belongs to?
# How many times this sequence has changed?

# Import the Entrez module from Biopython for accessing NCBI databases
from Bio import Entrez

# Function to fetch mRNA sequence using the provided accession number
def fetch_mrna_sequence(accession):
    Entrez.email = "marcin.bazyliszek@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="nucleotide", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "nucleotide" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched mRNA sequence as a string

# Example usage
mrna_accession = "NM_000518"  # You can also replace with the accession number of your mRNA of interest
sequence = fetch_mrna_sequence(mrna_accession)  # Call the function with the accession number to retrieve the sequence
print(sequence)  # Print the retrieved mRNA sequence

# Task2.4 Can you inspect how version 1 vs 5 of NM_000518 has changed?
mrna_accession_1 = "NM_000518.1"
sequence_1 = fetch_mrna_sequence(mrna_accession)
print(sequence_1)
print('The length of v1 is', len(sequence_1))

mrna_accession_5 = "NM_000518.5"
sequence_5 = fetch_mrna_sequence(mrna_accession_5)
print(sequence_5)
print('The length of v5 is', len(sequence_5))

from Bio import pairwise2
from Bio.Seq import Seq
alignments = pairwise2.align.globalxx(sequence_1, sequence_5)

for alignment in alignments:
    print(pairwise2.format_alignment(*alignment))

# Task2.5 Get the genomic Sequence from accession number 'NM_000518', which subunit of a protein is this?
# Import the Entrez module from Biopython for accessing NCBI databases 'NM_000518'
from Bio import Entrez
# Function to fetch genomic sequence using the provided accession number
def fetch_genomic_sequence(accession):
    Entrez.email = "marcin.bazyliszek@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="nuccore", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "nuccore" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched genomic sequence as a string

# Example usage
genomic_accession = "NM_000518"  # Replace with the accession number of your genomic sequence of interest
sequence = fetch_genomic_sequence(genomic_accession)  # Call the function with the accession number to retrieve the sequence
print('This sequence is as following:', sequence)  # Print the retrieved genomic sequence
print(len(sequence))

# Task2.6 PDB Structure Retrival

# Import the PDBList module from Biopython for accessing the Protein Data Bank (PDB)
from Bio.PDB import PDBList

# Function to fetch PDB structure using the provided PDB ID
def fetch_pdb_structure(pdb_id):
    pdbl = PDBList()
    # Create a PDBList object to interact with the PDB database

    pdbl.retrieve_pdb_file(pdb_id, file_format="pdb", pdir="./")
    # Use the retrieve_pdb_file method to fetch the PDB structure with the given PDB ID
    # 'file_format="pdb"' specifies that the data should be returned in PDB format (structure data).
    # 'pdir="./"' indicates that the downloaded PDB file will be saved in the current directory.

    pdb_filename = f"pdb{pdb_id.lower()}.ent"
    # The downloaded PDB file will have a filename in the format "pdbXXXX.ent", where XXXX is the PDB ID in lowercase.

    return pdb_filename  # Return the filename of the downloaded PDB structure


# Example usage
pdb_id = "1CRN"  # Replace with the PDB ID of the structure you want to retrieve (1CRN)
pdb_filename = fetch_pdb_structure(pdb_id)  # Call the function with the PDB ID to retrieve the structure
print(f"PDB structure {pdb_id} downloaded as {pdb_filename}")  # Print the filename of the downloaded PDB structure

#Inspect the file that was created pdb1crn.ent

# Task2.7 Querying Database with TEX101 gene. What are other synonyms of this gene?
# Import necessary modules from Biopython
from Bio import Entrez, Medline, SeqIO

# Set your email address for NCBI Entrez access
Entrez.email = "marcin.bazyliszek@gmail.com" #use your email account

# Use Entrez to retrieve information about available databases
handle = Entrez.einfo()
rec = Entrez.read(handle)
print(rec)

# Search for nucleotide sequences with gene name "TEX101" from "Homo sapiens" # was CRT and  Plasmodium falciparum
handle = Entrez.esearch(db="nucleotide", term='TEX101[Gene Name] AND "Homo sapiens"[Organism]')
rec_list = Entrez.read(handle)

# If there are more results than the default limit, fetch all results
if int(rec_list['RetMax']) < int(rec_list['Count']):
    handle = Entrez.esearch(db="nucleotide", term='TEX101[Gene Name] AND "Homo sapiens"[Organism]',
                            retmax=rec_list['Count'])
    rec_list = Entrez.read(handle)

# Retrieve the list of matching sequence IDs
id_list = rec_list['IdList']

# Fetch the records corresponding to the retrieved IDs in GenBank format
hdl = Entrez.efetch(db='nucleotide', id=id_list, rettype='gb', retmax=rec_list['Count'])
recs = list(SeqIO.parse(hdl, 'gb'))

# Search for a specific sequence with name "NM_001130011"
for rec in recs:
    if rec.name == 'NM_001130011':  #was KM288867
        break
print(rec.name)
print(rec.description)

# Analyze sequence features
for feature in rec.features:
    if feature.type == 'gene':
        print(feature.qualifiers['gene'])
    elif feature.type == 'exon':
        loc = feature.location
        print('Exon', loc.start, loc.end, loc.strand)
    else:
        print('not processed:\n%s' % feature)

# Print annotations of the retrieved sequence
for name, value in rec.annotations.items():
    print('%s=%s' % (name, value))

# Print the length of the sequence
print(len(rec.seq))

# Retrieve and display the references associated with the sequence
refs = rec.annotations['references']
print(refs)
for ref in refs:
    if ref.pubmed_id != '':
        print(ref.pubmed_id)
        handle = Entrez.efetch(db="pubmed", id=[ref.pubmed_id],
                                rettype="medline", retmode="text")
        records = Medline.parse(handle)
        for med_rec in records:
            for k, v in med_rec.items():
                print('%s: %s' % (k, v))

# Task2.8 Filtering retrieved data
# Import the SeqIO module from Biopython for parsing sequence data from files
from Bio import SeqIO

# Function to filter sequences based on their length
def filter_sequences_by_length(sequences, min_length):
    filtered_sequences = []  # Create an empty list to store the filtered sequences
    for sequence in sequences:
        if len(sequence) >= min_length:
            # Check if the length of the sequence is greater than or equal to the minimum length
            # If the condition is met, add the sequence to the filtered_sequences list
            filtered_sequences.append(sequence)
    return filtered_sequences  # Return the list of filtered sequences

# Example usage
fasta_file = "sequence.fasta"  # Replace with the filename of your FASTA file containing sequences
fasta_file = "my_sequence.fasta"  # Replace with the filename of your FASTA file containing sequences
fasta_file = "/content/sample_data/my_sequence.fasta"

# https://www.ncbi.nlm.nih.gov/nuccore/NM_001130011.3?report=fasta
min_length = 100  # Set the minimum length for filtering sequences
sequences = SeqIO.parse(fasta_file, "fasta")  # Parse the FASTA file to get a sequence iterator
filtered_sequences = filter_sequences_by_length(sequences, min_length)  # Call the function to filter sequences
for sequence in filtered_sequences:
    print('My fasta file has following sequence', sequence)  # Print the filtered sequences

# Task2.9 Reading and writing. What is the ID of the fastqc? What is the length of it?
from Bio import SeqIO
# Read sequences from a FASTA file
#sequences = SeqIO.parse("sequence.fasta", "fasta")
sequences = SeqIO.parse("/content/sample_data/my_sequence.fasta", "fasta")

# Iterate over the sequences and print their IDs and lengths
for sequence in sequences:
    print("ID:", sequence.id)
    print("Length:", len(sequence))

"""#PART 3 - Single cell analysis - if you made to this part that means you deserve some additional credits to perform differential analysis"""

!pip install pydeseq2
#!pip install --upgrade numpy
#https://pydeseq2.readthedocs.io/en/stable/
#!pip install --upgrade scikit-learn==1.3.0 scanpy==1.9.3

"""#Task3.1. what is the size of the raw imported count object? What is ENSG00000271254? remember to have correct file
#The file you need you can find it here # https://github.com/bazyliszek/OsloMet2025

import sys
from pydeseq2.dds import DeseqDataSet
import pandas as pd
from pydeseq2.ds import DeseqStats

from pydeseq2.dds import DeseqDataSet
import pandas as pd
from pydeseq2.ds import DeseqStats


counts = pd.read_csv('/content/sample_data/2025_count_table_for_deseq_example.csv')
print(counts)
"""

import sys
from pydeseq2.dds import DeseqDataSet
import pandas as pd
from pydeseq2.ds import DeseqStats

counts = pd.read_csv('/content/sample_data/2025_count_table_for_deseq_example.csv')
print(counts)

counts = counts.set_index('Geneid')
print(counts)

counts = counts[counts.sum(axis=1) > 0]
print(counts)

counts = counts.T
print(counts)

metadata = pd.DataFrame(zip(counts.index, ['C', 'C', 'C', 'C', 'RS', 'RS', 'RS', 'RS']), columns=['Sample', 'Condition'])
metadata = metadata.set_index('Sample')
print(metadata)

dds = DeseqDataSet(counts=counts, metadata=metadata, design_factors="Condition")
dds.deseq2()
print(dds)

stat_res = DeseqStats(dds, contrast=['Condition', 'RS', 'C'])
#make summary statistics
stat_res.summary()

res = stat_res.results_df
print(res)

!pip install sanbomics

from sanbomics.tools import id_map
mapper = id_map(species='human')
res['Symbol'] = res.index.map(mapper.mapper)
res = res[res.baseMean >= 10]

print(res)

sigs = res[(res.padj < 0.05) & (abs(res.log2FoldChange) > 0.5)]
print(sigs)

!pip install scanpy
#!pip install --user scanpy
#!pip install --upgrade numpy scikit-learn scanpy
#!pip install --upgrade scikit-learn==1.3.0 scanpy==1.9.3

#!pip install -U scikit-learn ##This works after instaltion   scikit-learn
import scanpy as sc

sc.tl.pca(dds)
sc.pl.pca(dds, color='Condition', size=200)

#import scanpy as sc
#sc.tl.pca(dds, svd_solver='arpack')
#sc.pl.pca(dds, color='Condition', size=200)

import numpy as np
import seaborn as sns
dds.layers['normed_counts']
dds.layers['log1p'] = np.log1p(dds.layers['normed_counts'])
dds.layers['log1p']

print(sigs)
dds_sigs = dds[:, sigs.index]
print(dds_sigs)

grapher = pd.DataFrame(dds_sigs.layers['log1p'].T, index=dds_sigs.var_names, columns=dds_sigs.obs_names)
sns.clustermap(grapher, z_score=0, cmap = 'RdYlBu_r')



import pandas as pd
anno = pd.read_csv(filename_sample_annotation)
adata.obs['cell_groups'] = anno['cell_groups']  # categorical annotation of type pandas.Categorical
adata.obs['time'] = anno['time']                # numerical annotation of type float
# alternatively, you could also set the whole dataframe
# adata.obs = anno

"""#Part V - based on https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html"""

# Install Core scverse libraries
!pip install -U scikit-learn
!pip install scanpy
!pip install pooch

# Core scverse libraries
import scanpy as sc
import anndata as ad

# Data retrieval
import pooch

sc.settings.set_figure_params(dpi=50, facecolor="white")

EXAMPLE_DATA = pooch.create(
    path=pooch.os_cache("scverse_tutorials"),
    base_url="doi:10.6084/m9.figshare.22716739.v1/",
)
EXAMPLE_DATA.load_registry_from_doi()

samples = {
    "s1d1": "s1d1_filtered_feature_bc_matrix.h5",
    "s1d3": "s1d3_filtered_feature_bc_matrix.h5",
}
adatas = {}

for sample_id, filename in samples.items():
    path = EXAMPLE_DATA.fetch(filename)
    sample_adata = sc.read_10x_h5(path)
    sample_adata.var_names_make_unique()
    adatas[sample_id] = sample_adata

adata = ad.concat(adatas, label="sample")
adata.obs_names_make_unique()
print(adata.obs["sample"].value_counts())
adata

print(sample)

# mitochondrial genes, "MT-" for human, "Mt-" for mouse
adata.var["mt"] = adata.var_names.str.startswith("MT-")
# ribosomal genes
adata.var["ribo"] = adata.var_names.str.startswith(("RPS", "RPL"))
# hemoglobin genes
adata.var["hb"] = adata.var_names.str.contains("^HB[^(P)]")

sc.pp.calculate_qc_metrics(
    adata, qc_vars=["mt", "ribo", "hb"], inplace=True, log1p=True
)

sc.pl.violin(
    adata,
    ["n_genes_by_counts", "total_counts", "pct_counts_mt"],
    jitter=0.4,
    multi_panel=True,
)

sc.pl.scatter(adata, "total_counts", "n_genes_by_counts", color="pct_counts_mt")

sc.pp.filter_cells(adata, min_genes=100)
sc.pp.filter_genes(adata, min_cells=3)

sc.pp.scrublet(adata, batch_key="sample")

# Saving count data
adata.layers["counts"] = adata.X.copy()

# Normalizing to median total counts
sc.pp.normalize_total(adata)
# Logarithmize the data
sc.pp.log1p(adata)

sc.pp.highly_variable_genes(adata, n_top_genes=2000, batch_key="sample")

sc.pl.highly_variable_genes(adata)

sc.tl.pca(adata)

sc.pl.pca_variance_ratio(adata, n_pcs=50, log=True)

sc.pl.pca(
    adata,
    color=["sample", "sample", "pct_counts_mt", "pct_counts_mt"],
    dimensions=[(0, 1), (2, 3), (0, 1), (2, 3)],
    ncols=2,
    size=2,
)

sc.pp.neighbors(adata)

sc.tl.umap(adata)

sc.pl.umap(
    adata,
    color="sample",
    # Setting a smaller point size to get prevent overlap
    size=2,
)

!pip install igraph

# Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets
sc.tl.leiden(adata, flavor="igraph", n_iterations=2)

sc.pl.umap(adata, color=["leiden"])

sc.pl.umap(
    adata,
    color=["leiden", "predicted_doublet", "doublet_score"],
    # increase horizontal space between panels
    wspace=0.5,
    size=3,
)

sc.pl.umap(
    adata,
    color=["leiden", "log1p_total_counts", "pct_counts_mt", "log1p_n_genes_by_counts"],
    wspace=0.5,
    ncols=2,
)

sc.pl.umap(
    adata,
    color=["leiden", "log1p_total_counts", "pct_counts_mt", "log1p_n_genes_by_counts"],
    wspace=0.5,
    ncols=2,
)

for res in [0.02, 0.5, 2.0]:
    sc.tl.leiden(
        adata, key_added=f"leiden_res_{res:4.2f}", resolution=res, flavor="igraph"
    )

sc.pl.umap(
    adata,
    color=["leiden_res_0.02", "leiden_res_0.50", "leiden_res_2.00"],
    legend_loc="on data",
)

sc.pl.umap(
    adata,
    color=["leiden_res_0.02", "leiden_res_0.50", "leiden_res_2.00"],
    legend_loc="on data",
)

marker_genes = {
    "CD14+ Mono": ["FCN1", "CD14"],
    "CD16+ Mono": ["TCF7L2", "FCGR3A", "LYN"],
    # Note: DMXL2 should be negative
    "cDC2": ["CST3", "COTL1", "LYZ", "DMXL2", "CLEC10A", "FCER1A"],
    "Erythroblast": ["MKI67", "HBA1", "HBB"],
    # Note HBM and GYPA are negative markers
    "Proerythroblast": ["CDK6", "SYNGR1", "HBM", "GYPA"],
    "NK": ["GNLY", "NKG7", "CD247", "FCER1G", "TYROBP", "KLRG1", "FCGR3A"],
    "ILC": ["ID2", "PLCG2", "GNLY", "SYNE1"],
    "Naive CD20+ B": ["MS4A1", "IL4R", "IGHD", "FCRL1", "IGHM"],
    # Note IGHD and IGHM are negative markers
    "B cells": [
        "MS4A1",
        "ITGB1",
        "COL4A4",
        "PRDM1",
        "IRF4",
        "PAX5",
        "BCL11A",
        "BLK",
        "IGHD",
        "IGHM",
    ],
    "Plasma cells": ["MZB1", "HSP90B1", "FNDC3B", "PRDM1", "IGKC", "JCHAIN"],
    # Note PAX5 is a negative marker
    "Plasmablast": ["XBP1", "PRDM1", "PAX5"],
    "CD4+ T": ["CD4", "IL7R", "TRBC2"],
    "CD8+ T": ["CD8A", "CD8B", "GZMK", "GZMA", "CCL5", "GZMB", "GZMH", "GZMA"],
    "T naive": ["LEF1", "CCR7", "TCF7"],
    "pDC": ["GZMB", "IL3RA", "COBLL1", "TCF4"],
}

sc.pl.dotplot(adata, marker_genes, groupby="leiden_res_0.02", standard_scale="var")

adata.obs["cell_type_lvl1"] = adata.obs["leiden_res_0.02"].map(
    {
        "0": "Lymphocytes",
        "1": "Monocytes",
        "2": "Erythroid",
        "3": "B Cells",
    }
)

sc.pl.dotplot(adata, marker_genes, groupby="leiden_res_0.50", standard_scale="var")

# Obtain cluster-specific differentially expressed genes
sc.tl.rank_genes_groups(adata, groupby="leiden_res_0.50", method="wilcoxon")

sc.pl.rank_genes_groups_dotplot(
    adata, groupby="leiden_res_0.50", standard_scale="var", n_genes=5
)

sc.get.rank_genes_groups_df(adata, group="7").head(5)

dc_cluster_genes = sc.get.rank_genes_groups_df(adata, group="7").head(5)["names"]
sc.pl.umap(
    adata,
    color=[*dc_cluster_genes, "leiden_res_0.50"],
    legend_loc="on data",
    frameon=False,
    ncols=3,
)