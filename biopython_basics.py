# -*- coding: utf-8 -*-
"""Biopython_Basics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Mpyixpcu75rwM17OolBFIogP9kBqpw-T

# ✨✨✨✨ Part 1 BIOPYTHON ✨✨✨✨

# ✨ Installation of Packages ✨
"""

!pip install SeqIO
!pip install biopython

"""# ✨ Task1.1.  What is reverse complement of the DNA sequence 'ATCGGTAATGATAGATGA'? ✨"""

#Task1.1. You should do this exercise with your neibour

import sys
from Bio.Seq import Seq
# Create a DNA sequence
#Note: Modify the line below to work with the string you want to find the reverse complement for
sequence = Seq("ATCGA")
# Get the reverse complement
reverse_complement = sequence.reverse_complement()
# Print the reverse complement
print(reverse_complement)

"""# ✨ Task1.2 Example of transcription (DNA to RNA). ✨
* What is the RNA transcript of the DNA sequence 'TTCCGATC'? ✨
"""

#Task1.2
from Bio.Seq import Seq
# Create a DNA sequence
#Note: Modify the line below to work with the string you want to find the transcript of.
dna_sequence = Seq("ATCGGTA")
# Perform transcription
rna_sequence = dna_sequence.transcribe()
# Print the RNA sequence
print(rna_sequence)

"""# ✨ Task1.3 Translation in action: Converting DNA/RNA into a Protein Sequence. ✨
* What is the protein sequence encoded by the DNA sequence"ATGCCTAATTTAGATGATGATGATGAAGCTTACGTAGATAGA"? ✨
"""

#Task 1.3
from Bio.Seq import Seq
# Create a DNA sequence (ok)
#Note: Remember what you need to modify in the line below!
dna_sequence = Seq("ATTTAGGATGAACTATGTGTGACAAATGGTGCCGTTGAGTCCTCTCAACTGGGAACGAGTCACCGTGTATCTGGAGACCATGTGTGTAACGGGTTGCACCTGCTTGGCTGGATACAAAGGTGGGATTTCTTTCTGTCTTTGTCATCTCTTAGCAGATTGTATCACATTTTGGCTTAATGCTTACTCAGTCATAAGACAAGTTTCTTTTAC")

# Perform translation to a part of the protein
protein_sequence = dna_sequence.translate()
# Print the protein sequence
print('This is your protein sequence', protein_sequence)

"""# ✨ Remember to place the file "my_sequnce.fasta" from this repository https://github.com/bazyliszek/OsloMet2025 to /content/sample_data/ ✨"""

from Bio import SeqIO

# Specify the correct FASTA file path and make sure your file is there
fasta_file = "/content/sample_data/my_sequence.fasta"
#fasta_file = "my_sequence.fasta"

# Read the FASTA file and extract the DNA sequence
for record in SeqIO.parse(fasta_file, "fasta"):
    dna_sequence = record.seq  # Extract the sequence as a Seq object

    # Translate DNA to Protein
    protein_sequence = dna_sequence.translate()

    protein_string = str(protein_sequence)
    proteins = protein_string.split("*")
    # Print the protein sequence
    #print(f"This is my protein sequence: {protein_sequence}")
    for protien in proteins:
      print(protien)

"""# ✨ Task1.4 Find the 3D structure of your favorite genes using AlphaFold: https://alphafold.ebi.ac.uk/ ✨

* How do you think these structures were derived? What is the model confidence for your protein?" ✨
* If you don't have a favorite protein yet, you can explore this one: https://alphafold.ebi.ac.uk/entry/Q9BY14." ✨
* We have been particularly interested in TEX101. You can read more about it here: https://pubmed.ncbi.nlm.nih.gov/35774118/. ✨

# ✨ What is the purpose of sequence alignment? ✨
* Describe this alignment in your own words to your colligue ✨
"""

from Bio import Align
# Create a pairwise sequence aligner
aligner = Align.PairwiseAligner()

# Add sequences to align
seq1 = "ACGTTAGATCTTATT"
seq2 = "TTAGGGAAAAAA"
alignments = aligner.align(seq1, seq2)

# Print the alignments
for alignment in alignments:
    print(alignment)

"""# ✨ Task1.5. Sequence Comparison Using Biopython: What is the match score between the sequences 'ATCGGTATTCA' and 'ATGGTCATTCA'? ✨"""

#Task1.5.
from Bio import pairwise2
from Bio.Seq import Seq

# Create two DNA sequences
seq1 = Seq("ATCGGTATTCA")
seq2 = Seq("ATGGTTTTTCA") #

# Perform pairwise sequence alignment
alignments = pairwise2.align.globalxx(seq1, seq2)

# Print the alignments
for alignment in alignments:
    print(pairwise2.format_alignment(*alignment))

"""✨ ✨ ✨ ✨ ✨ ✨ ✨ **#PART 2 DATABASES** ✨ ✨ ✨ ✨

# ✨ Task2.1.  Access the NCBI database at https://www.ncbi.nlm.nih.gov/  ✨
* What is the length of the sequence NC_000023.11? ✨
"""

#Task2.1.

import sys
# Import the Entrez module from Biopython for accessing NCBI databases
from Bio import Entrez
# Function to fetch genomic sequence using the provided accession number
def fetch_genomic_sequence(accession):
    Entrez.email = "XX.XX@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="nuccore", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "nuccore" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched genomic sequence as a string

# Example usage
genomic_accession = "NC_000019.10"  #Replace with the accession number of your genomic sequence of interest NC_000019.10
sequence = fetch_genomic_sequence(genomic_accession)  # Call the function with the accession number to retrieve the sequence
#print(sequence)  # Print the retrieved genomic sequence
print(len(sequence))

"""# ✨ Task2.2.Retrieve the protein sequence and name for the protein with ID 'NP_000508'. ✨

 * What is the length of this protein? What is the name of the protein with ID 'P01308.1'? ✨
"""

#Task2.2.

# Import the Entrez module from Biopython for accessing NCBI databases
from Bio import Entrez

# Function to fetch protein sequence using the provided accession number
def fetch_protein_sequence(accession):
    Entrez.email = "xxx.xxx@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="protein", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "protein" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched protein sequence as a string

# Example usage
protein_accession = "NP_000508"  # Replace with the accession number of your protein of interest
sequence = fetch_protein_sequence(protein_accession)  # Call the function with the accession number to retrieve the sequence
print(sequence)  # Print the retrieved protein sequence
print(len(sequence))

"""# ✨ Task2.3  Analyze and explore the mRNA sequence ✨
* To which species and gene does the mRNA ID 'NM_000518' belong? ✨
* How many times has this sequence changed over time?? ✨
"""

#Task2.3
# Import the Entrez module from Biopython for accessing NCBI databases

from Bio import Entrez

# Function to fetch mRNA sequence using the provided accession number
def fetch_mrna_sequence(accession):
    Entrez.email = "marcin.bazyliszek@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="nucleotide", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "nucleotide" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched mRNA sequence as a string

# Example usage
mrna_accession = "NM_000518"  # You can also replace with the accession number of your mRNA of interest
sequence = fetch_mrna_sequence(mrna_accession)  # Call the function with the accession number to retrieve the sequence
print(sequence)  # Print the retrieved mRNA sequence

"""# ✨ Task2.4 Can you analyze the differences between version 1 and version 5 of NM_000518? ✨"""

# Task2.4
mrna_accession_1 = "NM_000518.1"
sequence_1 = fetch_mrna_sequence(mrna_accession)
#print(sequence_1)
print('The length of v1 is', len(sequence_1))

mrna_accession_5 = "NM_000518.5"
sequence_5 = fetch_mrna_sequence(mrna_accession_5)
#print(sequence_5)
print('The length of v5 is', len(sequence_5))

from Bio import pairwise2
from Bio.Seq import Seq
alignments = pairwise2.align.globalxx(sequence_1, sequence_5)

for alignment in alignments:
    print(pairwise2.format_alignment(*alignment))
    break

"""# ✨ Task2.5 Retrieve the genomic sequence for accession number 'NM_000518'. ✨

* ✨ Which protein subunit does this sequence correspond to?" ✨
* ✨ Import the Entrez module from Biopython to access NCBI databases for 'NM_000518' ✨
"""

# Task2.5
from Bio import Entrez
# Function to fetch genomic sequence using the provided accession number
def fetch_genomic_sequence(accession):
    Entrez.email = "marcin.bazyliszek@gmail.com"  # Replace with your email address
    # Set the email address to allow NCBI to contact you in case of any issues
    handle = Entrez.efetch(db="nuccore", id=accession, rettype="fasta", retmode="text")
    # 'efetch' is used to fetch the sequence data from the "nuccore" database using the provided accession number.
    # 'rettype="fasta"' specifies that the data should be returned in FASTA format (sequence data).
    # 'retmode="text"' indicates that the data should be returned as a text string.
    record = handle.read()  # Read the fetched sequence data
    handle.close()  # Close the handle to release resources
    return record  # Return the fetched genomic sequence as a string

# Example usage
genomic_accession = "NM_000519"  # Replace with the accession number of your genomic sequence of interest
sequence = fetch_genomic_sequence(genomic_accession)  # Call the function with the accession number to retrieve the sequence
print('This sequence is as following:', sequence)  # Print the retrieved genomic sequence
print(len(sequence))

"""# ✨ Task2.6 Structure Retrival of a protein from Protein Data Bank (PDB) ✨
* How can you open and view a PDB file?
"""

# Task2.6

# Import the PDBList module from Biopython for accessing the Protein Data Bank (PDB)
from Bio.PDB import PDBList

# Function to fetch PDB structure using the provided PDB ID
def fetch_pdb_structure(pdb_id):
    pdbl = PDBList()
    # Create a PDBList object to interact with the PDB database

    pdbl.retrieve_pdb_file(pdb_id, file_format="pdb", pdir="./")
    # Use the retrieve_pdb_file method to fetch the PDB structure with the given PDB ID
    # 'file_format="pdb"' specifies that the data should be returned in PDB format (structure data).
    # 'pdir="./"' indicates that the downloaded PDB file will be saved in the current directory.

    pdb_filename = f"pdb{pdb_id.lower()}.ent"
    # The downloaded PDB file will have a filename in the format "pdbXXXX.ent", where XXXX is the PDB ID in lowercase.

    return pdb_filename  # Return the filename of the downloaded PDB structure


# Example usage
pdb_id = "1CRN"  # Replace with the PDB ID of the structure you want to retrieve (1CRN)
pdb_filename = fetch_pdb_structure(pdb_id)  # Call the function with the PDB ID to retrieve the structure
print(f"PDB structure {pdb_id} downloaded as {pdb_filename}")  # Print the filename of the downloaded PDB structure

#Inspect the file that was created pdb1crn.ent

"""# ✨ Task 2.7: Querying the Database for the TEX101 Gene   ✨
* ✨ What are the other known synonyms for this gene?  ✨

"""

# Task2.7
# Import necessary modules from Biopython
from Bio import Entrez, Medline, SeqIO

# Set your email address for NCBI Entrez access
Entrez.email = "marcin.bazyliszek@gmail.com" #use your email account

# Use Entrez to retrieve information about available databases
handle = Entrez.einfo()
rec = Entrez.read(handle)
print(rec)

# Search for nucleotide sequences with gene name "TEX101" from "Homo sapiens" # was CRT and  Plasmodium falciparum
handle = Entrez.esearch(db="nucleotide", term='TEX101[Gene Name] AND "Homo sapiens"[Organism]')
rec_list = Entrez.read(handle)

# If there are more results than the default limit, fetch all results
if int(rec_list['RetMax']) < int(rec_list['Count']):
    handle = Entrez.esearch(db="nucleotide", term='TEX101[Gene Name] AND "Homo sapiens"[Organism]',
                            retmax=rec_list['Count'])
    rec_list = Entrez.read(handle)

# Retrieve the list of matching sequence IDs
id_list = rec_list['IdList']

# Fetch the records corresponding to the retrieved IDs in GenBank format
hdl = Entrez.efetch(db='nucleotide', id=id_list, rettype='gb', retmax=rec_list['Count'])
recs = list(SeqIO.parse(hdl, 'gb'))

# Search for a specific sequence with name "NM_001130011"
for rec in recs:
    if rec.name == 'NM_001130011':  #was KM288867
        break
print(rec.name)
print(rec.description)

# Analyze sequence features
for feature in rec.features:
    if feature.type == 'gene':
        print(feature.qualifiers['gene'])
    elif feature.type == 'exon':
        loc = feature.location
        print('Exon', loc.start, loc.end, loc.strand)
    else:
        print('not processed:\n%s' % feature)

# Print annotations of the retrieved sequence
for name, value in rec.annotations.items():
    print('%s=%s' % (name, value))

# Print the length of the sequence
print(len(rec.seq))

# Retrieve and display the references associated with the sequence
refs = rec.annotations['references']
print(refs)
for ref in refs:
    if ref.pubmed_id != '':
        print(ref.pubmed_id)
        handle = Entrez.efetch(db="pubmed", id=[ref.pubmed_id],
                                rettype="medline", retmode="text")
        records = Medline.parse(handle)
        for med_rec in records:
            for k, v in med_rec.items():
                print('%s: %s' % (k, v))

"""# ✨ Task2.8 Filtering retrieved sequenced data based on length ✨"""

# Task2.8
# Import the SeqIO module from Biopython for parsing sequence data from files
from Bio import SeqIO

# Function to filter sequences based on their length
def filter_sequences_by_length(sequences, min_length):
    filtered_sequences = []  # Create an empty list to store the filtered sequences
    for sequence in sequences:
        if len(sequence) >= min_length:
            # Check if the length of the sequence is greater than or equal to the minimum length
            # If the condition is met, add the sequence to the filtered_sequences list
            filtered_sequences.append(sequence)
    return filtered_sequences  # Return the list of filtered sequences

# Example usage
fasta_file = "sequence.fasta"  # Replace with the filename of your FASTA file containing sequences
fasta_file = "my_sequence.fasta"  # Replace with the filename of your FASTA file containing sequences
fasta_file = "/content/sample_data/my_sequence.fasta"

# https://www.ncbi.nlm.nih.gov/nuccore/NM_001130011.3?report=fasta
min_length = 100  # Set the minimum length for filtering sequences
sequences = SeqIO.parse(fasta_file, "fasta")  # Parse the FASTA file to get a sequence iterator
filtered_sequences = filter_sequences_by_length(sequences, min_length)  # Call the function to filter sequences
for sequence in filtered_sequences:
    print('My fasta file has following sequence', sequence)  # Print the filtered sequences

"""# ✨ Task 2.9 Reading and Writing:  ✨
* What is the ID of the FASTQ file?  ✨
* What is its length? ✨
"""

# Task2.9
from Bio import SeqIO
# Read sequences from a FASTA file
#sequences = SeqIO.parse("sequence.fasta", "fasta")
sequences = SeqIO.parse("/content/sample_data/my_sequence.fasta", "fasta")

# Iterate over the sequences and print their IDs and lengths
for sequence in sequences:
    print("ID:", sequence.id)
    print("Length:", len(sequence))

"""# ✨ PART 3 - Single cell analysis ✨"""

!pip install pydeseq2
#!pip install --upgrade numpy
#https://pydeseq2.readthedocs.io/en/stable/
#!pip install --upgrade scikit-learn==1.3.0 scanpy==1.9.3

"""# ✨ Task3.1. What is the dimation of the raw imported count object?  ✨
* What is ENSG00000271254? Remember to have correct file ✨
* The file you need you can find it here # https://github.com/bazyliszek/OsloMet2025  ✨
"""

import sys
from pydeseq2.dds import DeseqDataSet
import pandas as pd
from pydeseq2.ds import DeseqStats

counts = pd.read_csv('/content/sample_data/2025_count_table_for_deseq_example.csv')
#counts = pd.read_csv('2025_count_table_for_deseq_example.csv')
print(counts)

counts = counts.set_index('Geneid')
print(counts)

"""# ✨ Task3.2. What is the dimation of the the count object with count more than 0? ✨"""

counts = counts[counts.sum(axis=1) > 0]
print(counts)

counts = counts.T # transformation
print(counts)

""" # ✨ Task3.3. Which contrast you can make in this experiment ✨"""

metadata = pd.DataFrame(zip(counts.index, ['C', 'C', 'C', 'C', 'RS', 'RS', 'RS', 'RS']), columns=['Sample', 'Condition'])
metadata = metadata.set_index('Sample')
print(metadata)

"""# ✨ This object stores the raw count data, metadata (sample information), and the experimental design. ✨

* counts=counts: Provides the raw count matrix (gene expression values for each sample).
* metadata=metadata: Supplies sample metadata, which includes conditions or other experimental factors.
* design_factors="Condition": Specifies that "Condition" is the factor of interest (e.g., control vs. treated samples) for differential expression analysis.
"""

dds = DeseqDataSet(counts=counts, metadata=metadata, design_factors="Condition")
dds.deseq2()
print(dds)

"""# ✨ Purpose in RNA-Seq Analysis ✨

* ✨ This dataset (dds) is used in differential gene expression analysis to compare expression levels between conditions (e.g., treated vs. control). ✨
* ✨ It is then normalized and tested for statistically significant changes in expression. ✨
"""

stat_res = DeseqStats(dds, contrast=['Condition', 'RS', 'C'])
#make summary statistics
stat_res.summary()

res = stat_res.results_df
print(res)

"""# # ✨ Create a Volcano Plot with a Log2 Fold Change Threshold of 2 and alpha of 0.01 ✨
* Explain this graph ✨
* How to show names of the genes that are differentially expressed?
"""

import pandas as pd

# Extract DESeq2 results as a DataFrame
results_df = stat_res.results_df

# Display first few rows
results_df.head()


# Define significance thresholds
alpha = 0.05  # Adjusted p-value threshold
log2fc_threshold = 1  # Fold change threshold

# Add a column for significance
results_df["Significance"] = "Not Significant"
results_df.loc[
    (results_df["padj"] < alpha) & (results_df["log2FoldChange"] > log2fc_threshold), "Significance"
] = "Upregulated"
results_df.loc[
    (results_df["padj"] < alpha) & (results_df["log2FoldChange"] < -log2fc_threshold), "Significance"
] = "Downregulated"

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Convert p-values to -log10(padj) for better visualization
results_df["-log10(padj)"] = -np.log10(results_df["padj"])

# Create the Volcano plot
plt.figure(figsize=(10, 6))
sns.scatterplot(
    x=results_df["log2FoldChange"],
    y=results_df["-log10(padj)"],
    hue=results_df["Significance"],
    palette={"Upregulated": "red", "Downregulated": "blue", "Not Significant": "gray"},
    alpha=0.7
)

# Add axis labels and title
plt.axhline(y=-np.log10(alpha), color="black", linestyle="--", linewidth=1)  # Significance threshold
plt.axvline(x=log2fc_threshold, color="black", linestyle="--", linewidth=1)  # Fold change threshold
plt.axvline(x=-log2fc_threshold, color="black", linestyle="--", linewidth=1)

plt.xlabel("Log2 Fold Change")
plt.ylabel("-Log10 Adjusted P-value")
plt.title("Volcano Plot of Differentially Expressed Genes")
plt.legend(title="Significance")

# Label significant genes
#for i, row in results_df.iterrows():
#    if row["Significance"] in ["Upregulated", "Downregulated"]:
#        plt.text(row["log2FoldChange"], row["-log10(padj)"], row["Symbol"], fontsize=8, ha='right') #row.name

#plt.show()

!pip install sanbomics

from sanbomics.tools import id_map
mapper = id_map(species='human')
res['Symbol'] = res.index.map(mapper.mapper)
res = res[res.baseMean >= 10]

print(res)

sigs = res[(res.padj < 0.05) & (abs(res.log2FoldChange) > 0.5)]
print(sigs)

# Filter significant genes (padj < 0.01 and |log2FC| > 0.5)
sigs = res[(res.padj < 0.01) & (abs(res.log2FoldChange) > 0.5)]

# Sort by absolute log2 fold change in descending order
sigs_sorted = sigs.sort_values(by="log2FoldChange", key=abs, ascending=False)

# Display the top results
sigs_sorted.head()

!pip install scanpy
#!pip install --user scanpy
#!pip install --upgrade numpy scikit-learn scanpy
#!pip install --upgrade scikit-learn==1.3.0 scanpy==1.9.3

!pip install -U scikit-learn ##This works after instaltion   scikit-learn ✨✨✨✨

import scanpy as sc

sc.tl.pca(dds)
sc.pl.pca(dds, color='Condition', size=300)

#import scanpy as sc
#sc.tl.pca(dds, svd_solver='arpack')
#sc.pl.pca(dds, color='Condition', size=200)

"""# ✨ Generate and visualize a clustering analysis ✨"""

import numpy as np
import seaborn as sns
dds.layers['normed_counts']
dds.layers['log1p'] = np.log1p(dds.layers['normed_counts'])
dds.layers['log1p']

print(sigs)
dds_sigs = dds[:, sigs.index]
print(dds_sigs)

grapher = pd.DataFrame(dds_sigs.layers['log1p'].T, index=dds_sigs.var_names, columns=dds_sigs.obs_names)
sns.clustermap(grapher, z_score=0, cmap = 'RdYlBu_r')

"""# ✨ Part V - Single cell RNA ✨
* Based on https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html
"""

# Install Core scverse libraries
!pip install -U scikit-learn
!pip install scanpy
!pip install pooch

# Core scverse libraries
import scanpy as sc
import anndata as ad

# Data retrieval
import pooch

sc.settings.set_figure_params(dpi=50, facecolor="white")

EXAMPLE_DATA = pooch.create(
    path=pooch.os_cache("scverse_tutorials"),
    base_url="doi:10.6084/m9.figshare.22716739.v1/",
)
EXAMPLE_DATA.load_registry_from_doi()

samples = {
    "s1d1": "s1d1_filtered_feature_bc_matrix.h5",
    "s1d3": "s1d3_filtered_feature_bc_matrix.h5",
}
adatas = {}

for sample_id, filename in samples.items():
    path = EXAMPLE_DATA.fetch(filename)
    sample_adata = sc.read_10x_h5(path)
    sample_adata.var_names_make_unique()
    adatas[sample_id] = sample_adata

adata = ad.concat(adatas, label="sample")
adata.obs_names_make_unique()
print(adata.obs["sample"].value_counts())
adata

# mitochondrial genes, "MT-" for human, "Mt-" for mouse
adata.var["mt"] = adata.var_names.str.startswith("MT-")
# ribosomal genes
adata.var["ribo"] = adata.var_names.str.startswith(("RPS", "RPL"))
# hemoglobin genes
adata.var["hb"] = adata.var_names.str.contains("^HB[^(P)]")

sc.pp.calculate_qc_metrics(
    adata, qc_vars=["mt", "ribo", "hb"], inplace=True, log1p=True
)

sc.pl.violin(
    adata,
    ["n_genes_by_counts", "total_counts", "pct_counts_mt"],
    jitter=0.4,
    multi_panel=True,
)

sc.pl.scatter(adata, "total_counts", "n_genes_by_counts", color="pct_counts_mt")

sc.pp.filter_cells(adata, min_genes=100)
sc.pp.filter_genes(adata, min_cells=3)

sc.pp.scrublet(adata, batch_key="sample")

# Saving count data
adata.layers["counts"] = adata.X.copy()

# Normalizing to median total counts
sc.pp.normalize_total(adata)
# Logarithmize the data
sc.pp.log1p(adata)

sc.pp.highly_variable_genes(adata, n_top_genes=2000, batch_key="sample")

sc.pl.highly_variable_genes(adata)

sc.tl.pca(adata)

sc.pl.pca_variance_ratio(adata, n_pcs=50, log=True)

sc.pl.pca(
    adata,
    color=["sample", "sample", "pct_counts_mt", "pct_counts_mt"],
    dimensions=[(0, 1), (2, 3), (0, 1), (2, 3)],
    ncols=2,
    size=2,
)

sc.pp.neighbors(adata)

sc.tl.umap(adata)

sc.pl.umap(
    adata,
    color="sample",
    # Setting a smaller point size to get prevent overlap
    size=2,
)

!pip install igraph

# Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets
sc.tl.leiden(adata, flavor="igraph", n_iterations=2)

sc.pl.umap(adata, color=["leiden"])

sc.pl.umap(
    adata,
    color=["leiden", "predicted_doublet", "doublet_score"],
    # increase horizontal space between panels
    wspace=0.5,
    size=3,
)

sc.pl.umap(
    adata,
    color=["leiden", "log1p_total_counts", "pct_counts_mt", "log1p_n_genes_by_counts"],
    wspace=0.5,
    ncols=2,
)

for res in [0.02, 0.5, 2.0]:
    sc.tl.leiden(
        adata, key_added=f"leiden_res_{res:4.2f}", resolution=res, flavor="igraph"
    )

sc.pl.umap(
    adata,
    color=["leiden_res_0.02", "leiden_res_0.50", "leiden_res_2.00"],
    legend_loc="on data",
)

sc.pl.umap(
    adata,
    color=["leiden_res_0.02", "leiden_res_0.50", "leiden_res_2.00"],
    legend_loc="on data",
)

marker_genes = {
    "CD14+ Mono": ["FCN1", "CD14"],
    "CD16+ Mono": ["TCF7L2", "FCGR3A", "LYN"],
    # Note: DMXL2 should be negative
    "cDC2": ["CST3", "COTL1", "LYZ", "DMXL2", "CLEC10A", "FCER1A"],
    "Erythroblast": ["MKI67", "HBA1", "HBB"],
    # Note HBM and GYPA are negative markers
    "Proerythroblast": ["CDK6", "SYNGR1", "HBM", "GYPA"],
    "NK": ["GNLY", "NKG7", "CD247", "FCER1G", "TYROBP", "KLRG1", "FCGR3A"],
    "ILC": ["ID2", "PLCG2", "GNLY", "SYNE1"],
    "Naive CD20+ B": ["MS4A1", "IL4R", "IGHD", "FCRL1", "IGHM"],
    # Note IGHD and IGHM are negative markers
    "B cells": [
        "MS4A1",
        "ITGB1",
        "COL4A4",
        "PRDM1",
        "IRF4",
        "PAX5",
        "BCL11A",
        "BLK",
        "IGHD",
        "IGHM",
    ],
    "Plasma cells": ["MZB1", "HSP90B1", "FNDC3B", "PRDM1", "IGKC", "JCHAIN"],
    # Note PAX5 is a negative marker
    "Plasmablast": ["XBP1", "PRDM1", "PAX5"],
    "CD4+ T": ["CD4", "IL7R", "TRBC2"],
    "CD8+ T": ["CD8A", "CD8B", "GZMK", "GZMA", "CCL5", "GZMB", "GZMH", "GZMA"],
    "T naive": ["LEF1", "CCR7", "TCF7"],
    "pDC": ["GZMB", "IL3RA", "COBLL1", "TCF4"],
}

sc.pl.dotplot(adata, marker_genes, groupby="leiden_res_0.02", standard_scale="var")

adata.obs["cell_type_lvl1"] = adata.obs["leiden_res_0.02"].map(
    {
        "0": "Lymphocytes",
        "1": "Monocytes",
        "2": "Erythroid",
        "3": "B Cells",
    }
)

sc.pl.dotplot(adata, marker_genes, groupby="leiden_res_0.50", standard_scale="var")

# Obtain cluster-specific differentially expressed genes
sc.tl.rank_genes_groups(adata, groupby="leiden_res_0.50", method="wilcoxon")

sc.pl.rank_genes_groups_dotplot(
    adata, groupby="leiden_res_0.50", standard_scale="var", n_genes=5
)

sc.get.rank_genes_groups_df(adata, group="7").head(5)

dc_cluster_genes = sc.get.rank_genes_groups_df(adata, group="7").head(5)["names"]
sc.pl.umap(
    adata,
    color=[*dc_cluster_genes, "leiden_res_0.50"],
    legend_loc="on data",
    frameon=False,
    ncols=3,
)